%!TEX root = ../dokumentation.tex

\chapter{\label{sec:implementierung}Implementierung}
In diesem Kapitel geht es um die Implementierung des automatischen und manuellen Modus.

\section{Automatik Modus}
Im Modus Automatik wird die im folgenden beschriebene Logik ausgeführt. Der Beweiser arbeitet dabei mit sogenannten Sequenten. Ein Sequent enthält alle Formeln auf der Wahr bzw. auf der Falsch Seite, sowie einige weitere Mengen. Durch die Behandlung des aktuellen Tableau als Sequent, können die Ableitungsschritte mit Mengenoperationen umgesetzt werden. Die Definition der Sequenten, sowie der Mengenoperationen für die Ableitungsschritte in den unterschiedlichen Logiken, folgt über die nächsten Seiten.

\subsection{Aussagenlogik}
Für die Aussagenlogik ist der Sequent S ein Sechstupel (T, F, $\Gamma$, $\Pi$, $\Theta$, $\Psi$). Die Mengen sind wie folgt definiert:
\begin{description}
\item \textbf{T}: Die Menge der Formeln auf der Wahr-Seite des Tableau.

\item \textbf{F}: Die Menge der Formeln auf der Falsch-Seite des Tableau.

\item \textbf{$\Gamma$}: Die Menge der Formeln die in vorherigen Ableitungsschritten abgeleitet wurden und dabei auf der Wahr-Seite standen.

\item \textbf{$\Pi$}: Die Menge der Formeln die in vorherigen Ableitungsschritten abgeleitet wurden und dabei auf der Falsch-Seite standen.

\item \textbf{$\Theta$}: Die Menge der atomaren Aussagen auf der Wahr-Seite.

\item \textbf{$\Psi$}: Die Menge der atomaren Aussagen auf der Falsch-Seite.
\end{description}

Der Beweiser muss nun im Automatik Modus eine Ableitung von S zu S' durchführen bis gilt $\exists\alpha$ ($\alpha\in\Theta\wedge\alpha\in\Psi$) $\vee\neg\exists\alpha$ ($\alpha\in$ T)$\wedge\neg\exists\alpha$ ($\alpha\in$ F). Ist eine Ableitung verzweigend, so wird von S zu S$_{1}$' und S$_{2}$' abgeleitet. Die Ableitungsregeln von S zu S' werden im folgenden definiert.

\subsubsection{Atomare Aussage}
Wenn $\alpha\in\textrm{T}$ dann folgt S'=($\textrm{T}\setminus\lbrace\alpha\rbrace$, F, $\Gamma\cup\lbrace\alpha\rbrace$, $\Pi$, $\Theta\cup\lbrace\alpha\rbrace$, $\Psi$).\\
Wenn $\alpha\in\textrm{F}$ dann folgt S'=(T, $\textrm{F}\setminus\lbrace\alpha\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\rbrace$, $\Theta$, $\Psi\cup\lbrace\alpha\rbrace$).

\subsubsection{Negation}
Wenn $\neg\alpha\in\textrm{T}$ dann folgt S'=($\textrm{T}\setminus\lbrace\neg\alpha\rbrace$, $\textrm{F}\cup\lbrace\alpha\rbrace$, $\Gamma\cup\lbrace\neg\alpha\rbrace$, $\Pi$, $\Theta$, $\Psi$).\\
Wenn $\neg\alpha\in\textrm{F}$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $\textrm{F}\setminus\lbrace\neg\alpha\rbrace$, $\Gamma$, $\Pi\cup\lbrace\neg\alpha\rbrace$, $\Theta$, $\Psi$).

\subsubsection{Konjunktion}
Wenn $\alpha\wedge\beta\in\textrm{T}$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha,\beta\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, F, $\Gamma\cup\lbrace\alpha\wedge\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$).\\
Wenn $\alpha\wedge\beta\in\textrm{F}$ dann folgt S$_{1}$'=(T, $(\textrm{F}\cup\lbrace\alpha\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\wedge\beta\rbrace$, $\Theta$, $\Psi$) und S$_{2}$'=(T, $(\textrm{F}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\wedge\beta\rbrace$, $\Theta$, $\Psi$).

\subsubsection{Disjunktion}
Wenn $\alpha\vee\beta\in\textrm{T}$ dann folgt S$_{1}$'=($(\textrm{T}\cup\lbrace\alpha\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, F, $\Gamma\cup\lbrace\alpha\vee\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$) und S$_{2}$'=($(\textrm{T}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, F, $\Gamma\cup\lbrace\alpha\vee\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$).\\
Wenn $\alpha\vee\beta\in\textrm{F}$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha,\beta\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\vee\beta\rbrace$, $\Theta$, $\Psi$).

\subsubsection{Implikation}
Wenn $\alpha\rightarrow\beta\in\textrm{T}$ dann folgt S$_{1}$'=($\textrm{T}\setminus\lbrace\alpha\rightarrow\beta\rbrace$, $\textrm{F}\cup\lbrace\alpha\rbrace$, $\Gamma\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$) und S$_{2}$'=($(\textrm{T}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\rightarrow\beta\rbrace$, F, $\Gamma\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$).\\
Wenn $\alpha\rightarrow\beta\in\textrm{F}$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $(\textrm{F}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\rightarrow\beta\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Theta$, $\Psi$).

\subsubsection{Äquivalenz}
Wenn $\alpha\leftrightarrow\beta\in\textrm{T}$ dann folgt S$_{1}$'=($(\textrm{T}\cup\lbrace\alpha,\beta\rbrace)\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, F, $\Gamma\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$) und S$_{2}$'=($\textrm{T}\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, $\textrm{F}\cup\lbrace\alpha,\beta\rbrace$, $\Gamma\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Pi$, $\Theta$, $\Psi$).\\
Wenn $\alpha\leftrightarrow\beta\in\textrm{F}$ dann folgt S$_{1}$'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $(\textrm{F}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Theta$, $\Psi$) und S$_{2}$'=($\textrm{T}\cup\lbrace\beta\rbrace$, $(\textrm{F}\cup\lbrace\alpha\rbrace)\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Gamma$, $\Pi\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Theta$, $\Psi$).

\subsubsection{Umsetzung}
Die definierten Ableitungsregeln, werden mit dem Visitor Pattern abgearbeitet. \cite{gof_design_patterns} Das zugehörige Klassendiagramm ist in \autoref{fig:class_diag_tableau_prover} dargestellt.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55]{images/class_diag_tableau_prover.png}
\caption{Klassendiagram des Tableau Beweisers}
\label{fig:class_diag_tableau_prover}
\end{center}
\end{figure}

Dabei wird im Automatik Modus nach einigen in \autoref{sec:heuristiken} beschriebenen Heurisitken eine Formel in T oder F ausgewählt und darauf die Methode ``visit'' aufgerufen. Die Methode ``visit'' ist mit einem Python-Decorator definiert, und ruft auf dem übergebenden Objekt die Methode ``visited\_[Operator-Name]'' auf. Die entsprechende Operator-Methode führt dann die Ableitung am, in einem Dictionary gespeicherten Sequent aus. Beispielhaft ist die Implementierung der Ableitungsregel für die Konjunktion in \autoref{lst:impl_res_conjunction} dargestellt.

\begin{lstlisting}[caption={Implementierung der Ableitungsregel für die Konjunktion in Aussagenlogik},label=lst:impl_res_conjunction]
def visited_And(self, a: And):
	if self.visiting_false:
		# Create new fork
		lhs = self.create_copy(remove_false=a)
		rhs = self.create_copy(remove_false=a)
		lhs.add_to(false_exprs, a.lhs)
		rhs.add_to(false_exprs, a.rhs)
		self.children.append(lhs)
		self.children.append(rhs)
	else:
		self.add_to(true_exprs, a.lhs)
		self.add_to(true_exprs, a.rhs)
\end{lstlisting}

Die Methoden ``create\_copy'' und ``add\_to'' abstrahieren das Erstellen eines neuen TableauProver Objekts und das Hinzufügen einer Formel zu einer Menge im Sequent. Da das Entfernen der Formel aus der Menge T oder F sowie das Hinzufügen zur Menge $\Gamma$ oder $\Pi$ bei jedem Ableitungsschritt nötig ist, wird dies bereits vor dem Aufruf der ``visit''-Methode ausgeführt. Bei Verzweigungen wird die Formel in der ``create\_copy''-Methode aus dem neuen Sequent entfernt.

\subsubsection{\label{sec:heuristiken}Heuristiken}
Um die Effizienz des Beweisers zu erhöhen, also die Anzahl der benötigten Ableitungsschritte zu minimieren, erfolgt die Wahl der als nächstes abzuleitenden Formel nach einigen Heuristiken. Für die klassische Aussagenlogik ist diese nur die nicht-Verzweigung der Ableitung. Dadurch wird z.B. eine Konjunktion auf der Wahr-Seite abgeleitet, bevor eine Disjunktion auf der Wahr-Seite abgeleitet wird. Implementiert wird diese Heuristik durch Vergabe von Prioritäten für die einzelnen Operatoren, während der automatischen Ableitung, werden die Formeln nach dieser Priorität sortiert und dann abgeleitet. Die Prioritäten der Formeln für Wahr- und Falsch-Seite sind in \autoref{tbl:ableitungs_prios_junktoren_pl} dargestellt.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Operator & \multicolumn{2}{c|}{Priorität} \\
\cline{2-3}
 & Wahr-Seite & Falsch-Seite \\
\hline
Atomare Aussage & 0 & 0 \\
Negation & 1 & 1 \\
Konjunktion & 1 & 2 \\
Disjunktion & 2 & 1 \\
Implikation & 2 & 1 \\
Äquivalenz & 2 & 2 \\
\hline
\end{tabular}
\end{center}
\caption{\label{tbl:ableitungs_prios_junktoren_pl}Heuristik für Aussagenlogik}
\end{table}

Mit dieser Heuristik werden Formeln mit niedrigerer Priorität bevorzugt.

\subsection{Prädikatenlogik 1. Ordnung}
Für die Prädikatenlogik 1. Ordnung muss der Sequent erweitert werden zu (T, F, $\Gamma$, $\Pi$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, C, $\Omega$). Die neu eingeführten Mengen haben folgende Bedeutung:
\begin{description}
\item \textbf{$\Sigma$}: Menge von Tupeln ($\alpha$, $\sigma$). Wobei $\alpha$ ein bereits abgeleiteter Quantor auf der Wahr-Seite ist, der mehrfach abgearbeitet werden kann und $\sigma$ die Menge der Konstanten/Funktionen die auf den Quantor bereits angewendet wurden.

\item \textbf{$\Phi$}: Menge von Tupeln ($\alpha$, $\sigma$). Wobei $\alpha$ ein bereits abgeleiteter Quantor auf der Falsch-Seite ist, der mehrfach abgearbeitet werden kann und $\sigma$ die Menge der Konstanten/Funktionen die auf den Quantor bereits angewendet wurden.

\item \textbf{C}: Die Menge der eingeführten Konstanten. (Das Diskursuniversum)

\item \textbf{$\Omega$}: Die Menge der eingeführten Funktionen, wobei nur ein Name geführt wird und davon Ausgegangen wird, dass das Ergebnis zweier Funktionen gleich ist gdw. alle Eingabeparameter gleich sind. Z.B. für die Aussage P(f(X), Y), wäre die Funktion f Element der Menge $\Omega$.
\end{description}

Im Gegensatz zur Aussagenlogik, wird bei der Prädikatenlogik 1. Ordnung abgeleitet bis gilt $\exists\alpha(\alpha\in\Theta\wedge\alpha\in\Psi)\vee\neg\exists\alpha(\alpha\in\textrm{F}\vee\alpha\in\textrm{T})\wedge\forall\textrm{c}(\textrm{c}\in\textrm{C}\rightarrow\neg\exists(\alpha,\sigma)((\alpha,\sigma)\in\Sigma\wedge\textrm{c}\notin\sigma)\wedge\neg\exists(\alpha,\sigma)((\alpha,\sigma)\in\Phi\wedge\textrm{c}\notin\sigma))$. Diese Regel gilt nur, wenn keine Funktionen mit einer Stelligkeit >0 in $\Omega$ enthalten sind, also Funktionen der Form f($x_{1},x_{2},...,x_{i}$) mit i$\geq$1. Existiert eine solche Funktion und ein Allquantor auf der Wahr- bzw. ein Existenzquantor auf der Falsch-Seite, muss jede Verschachtelung der Funktion betrachtet werden. Sei z.B. $\Omega=\lbrace\textrm{f}\rbrace$, $\textrm{C}=\lbrace\textrm{A}\rbrace$ und $\forall\textrm{x P(x)}\in\textrm{T}$, dann muss die quantifizierte Variable x sowohl durch A als auch durch f(A), f(f(A)), f(f(..f(A)..)) ersetzt werden, was keine Terminierung des Beweisverfahrens (wenn keine Kontradiktion gefunden wird) mehr zulässt.

Die Regeln der Operatoren bleiben für die Prädikatenlogik 1. Ordnung die selben, wobei die Mengen $\Sigma,\Phi$,C und $\Omega$ jeweils unberührt bleiben. Für die zusätzlichen Quantoren, müssen die Ableitungsregeln neu definiert werden. Zur Definition werden zwei Hilfsfunktionen ``applied'' und ``permute'' benötigt. applied(x, $\tau$, $\Lambda$) ist wahr gdw. gilt $\exists(\alpha,\sigma)((\alpha,\sigma)\in\Lambda\wedge\alpha\equiv\tau\wedge\textrm{x}\in\sigma)$. permute(C, $\Omega$) gibt alle möglichen Verschachtelungen der Konstanten mit den Funktionen zurück.

\subsubsection{Allquantor}
Wenn $\forall\textrm{x}$ $\alpha\in\textrm{T}$ und $\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega))\rbrace)\setminus\lbrace\forall\textrm{x}$ $\alpha\rbrace$, F, $\Gamma\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Pi$, $\Theta$, $\Psi$, $\Sigma\cup\lbrace(\forall\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega))\rbrace$, $\Phi$, C, $\Omega$).

Wenn $\forall\textrm{x}$ $\alpha\in\textrm{T}$ und $\neg\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace)\setminus\lbrace\forall\textrm{x}$ $\alpha\rbrace$, F, $\Gamma\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Pi$, $\Theta$, $\Psi$, $\Sigma\cup\lbrace(\forall\textrm{x}$ $\alpha,\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace$, $\Phi$, $\lbrace\textrm{t}\rbrace$, $\Omega$).

Wenn $(\forall\textrm{x}$ $\alpha, \sigma)\in\Sigma$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega)\wedge\neg\textrm{applied(t},\forall\textrm{x}$ $\alpha, \Sigma)\rbrace$, F, $\Gamma$, $\Pi$, $\Theta$, $\Psi$, $(\Sigma\setminus\lbrace(\forall\textrm{x}$ $\alpha, \sigma)\rbrace)\cup\lbrace(\forall\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega)\rbrace$, $\Phi$, C, $\Omega$).

Wenn $\forall\textrm{x}$ $\alpha\in\textrm{F}$ und k eine Konstante die nicht in C vorhanden, dann folgt S'=(T, $\textrm{F}\cup\lbrace\alpha[k/x]\rbrace$, $\Gamma$, $\Pi\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, $\textrm{C}\cup\lbrace\textrm{k}\rbrace$, $\Omega$).

\subsubsection{Existenzquantor}
Wenn $\exists\textrm{x}$ $\alpha\in\textrm{T}$ und k eine Konstante die nicht in C vorhanden, dann folgt S'=($\textrm{T}\cup\lbrace\alpha[k/x]\rbrace$, F, $\Gamma\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Pi$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, $\textrm{C}\cup\lbrace\textrm{k}\rbrace$, $\Omega$).

Wenn $\exists\textrm{x}$ $\alpha\in\textrm{F}$ und $\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega))\rbrace)\setminus\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Gamma$, $\Pi\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega))\rbrace$, C, $\Omega$).

Wenn $\exists\textrm{x}$ $\alpha\in\textrm{F}$ und $\neg\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace)\setminus\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Gamma$, $\Pi\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace$, $\lbrace\textrm{t}\rbrace$, $\Omega$).

Wenn $(\exists\textrm{x}$ $\alpha, \sigma)\in\Phi$ dann folgt S'=(T, $\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega)\wedge\neg\textrm{applied(t},\exists\textrm{x}$ $\alpha, \Phi))\rbrace$, $\Gamma$, $\Pi$, $\Theta$, $\Psi$, $\Sigma$, $(\Phi\setminus\lbrace(\exists\textrm{x}$ $\alpha, \sigma)\rbrace)\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega)\rbrace$, C, $\Omega$).

\subsubsection{\label{sec:umsetzung_pred_logic}Umsetzung}
Wie bereits in \autoref{fig:class_diag_tableau_prover} angedeutet, werden die Ableitungsregeln für die Prädikatenlogik 1. Ordnung durch eine Subklasse der für die Aussagenlogik zuständigen Klasse angewandt. Diese implementiert dabei Funktionen zur Ableitung der Quantoren und überschreibt die Methode, die bestimmt, wann das Beweisverfahren terminiert. Eine Besonderheit stellt dabei die oben eingeführte ``permute''-Funktion dar, diese kann nicht direkt implementiert werden, da diese teilweise auf unendlich große Mengen abbildet. Deshalb erzeugt diese die verschachtelten Funktionen nur bis zu einer Verschachtelungstiefe n, ist das Beweisverfahren an einem Punkt, bei dem es terminieren würde (ohne Kontradiktion), wird n inkrementiert.

Um alle möglichen Kombinationen zu erzeugen, wird ein Algorithmus zur Umwandelung von Zahlen in ein anderes Zahlensystem in etwas abgewandelter Form verwendet:
\begin{description}
\item \textbf{1.} Setze ZS = C
\item \textbf{2.} Nehme |ZS| als Basis des Zahlensystems und die Elemente von ZS als dessen Zeichensatz.
\item \textbf{3.} Für jede Funktion $\textrm{f}\in\Omega$ mit Kardinalität k, zähle in diesem Zahlensystem von 0 bis |ZS|$^{\textbf{k}}$-1. Jede der ``Ziffern'' bildet einen Parametersatz der Funktion f, wobei mit führenden ``Nullen'' (in dem Zahlensystem) aufgefüllt wird, um auf die Länge k zu kommen. Die so erzeugten Funktionen werden der Menge Z hinzugefügt.
\item \textbf{4.} Setze $\textrm{ZS}=\textrm{ZS}\cup\textrm{Z}$ und wiederhole 2. n mal.
\item \textbf{5.} Gebe ZS zurück.
\end{description}

\textbf{Beispiel:} Sei $\textrm{C}=\lbrace\textrm{A,B}\rbrace$, $\Omega=\lbrace\textrm{f}\rbrace$ und n=2 wobei f eine zweistellige Funktion ist:
\begin{description}
\item \textbf{1. (1)} $\textrm{ZS}=\lbrace\textrm{A,B}\rbrace$
\item \textbf{2. (2)} Nehme 2 als Basis des Zahlensystems und $\lbrace\textrm{A,B}\rbrace$ als dessen Zeichensatz.
\item \textbf{3. (3)} Zähle von 0 bis 2$^{\textbf{2}}$-1=3: A, B, BA, BB $\Rightarrow$ $\textrm{Z}=\lbrace\textrm{f(A,A), f(A,B), f(B,A), f(B,B)}\rbrace$
\item \textbf{4. (4)} $\textrm{ZS}=\lbrace\textrm{A, B, f(A,A), f(A,B), f(B,A), f(B,B)}\rbrace$
\item \textbf{5. (2)} Nehme 6 als Basis des Zahlensystems und $\lbrace\textrm{A, B, f(A,A), f(A,B), f(B,A), f(B,B)}\rbrace$ als dessen Zeichensatz.
\item \textbf{6. (3)} Zähle von 0 bis 6$^{\textbf{2}}$-1=36: A, B, f(A,A), f(A,B), ..., f(B,B)f(B,B) $\Rightarrow$ \\ $\textrm{Z}=\lbrace\textrm{f(A,A), f(A,B), f(A,f(A,A)), f(A,f(A,B)), ..., f(f(B,B),f(B,B))}\rbrace$
\item \textbf{7. (4)} $\textrm{ZS}=\lbrace\textrm{A, B, f(A,A), f(A,B), f(B,A), f(B,B), f(A,f(A,A)), f(A,f(A,B)), ..., f(f(B,B), f(B,B))}\rbrace$
\item \textbf{8. (5)} Gebe $\lbrace\textrm{A, B, f(A,A), f(A,B), f(B,A), f(B,B), f(A,f(A,A)), f(A,f(A,B)), ..., f(f(B,B), f(B,B))}\rbrace$ zurück.
\end{description}

Zur einfacheren Implementierung der ``applied''-Funktion sowie der Ableitungsregeln, werden die Mengen $\Sigma$ und $\Phi$ als Python-Dictionaries mit der Formel als Index implementiert.

\subsubsection{Heuristiken}
Zusätzlich zur in \autoref{sec:heuristiken} vorgestellten Heuristik, die im folgenden erweitert wird, kann für die Prädikatenlogik 1. Ordnung zusätzlich eine weitere Heuristik angewendet werden.

Die Heuristik die bestimmt, ob die Ableitung eines Operators verzweigt, muss um die Quantoren erweitert werden. Die neuen Prioritäten sind in \autoref{tbl:ableitungs_prios_junktoren_fopl} dargestellt. Um zu verhindern, dass der Beweiser immer neue Ableitungen von mehrfach ableitbaren Formeln erzeugt, bekommen die eine niedrige Priorität. Das Einführen neuer Konstanten ist dem zu bevorzugen weshalb dies eine höhere Priorität bekommt.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Operator & \multicolumn{2}{c|}{Priorität} \\
\cline{2-3}
 & Wahr-Seite & Falsch-Seite \\
\hline
Prädikat & 0 & 0 \\
Negation & 1 & 1 \\
Konjunktion & 1 & 2 \\
Disjunktion & 2 & 1 \\
Implikation & 2 & 1 \\
Äquivalenz & 2 & 2 \\
Allquantor & 3 & 2 \\
Existenzquantor & 2 & 3 \\
\hline
\end{tabular}
\end{center}
\caption{\label{tbl:ableitungs_prios_junktoren_fopl}Erste Heuristik für Prädikatenlogik 1. Ordnung}
\end{table}

Die zweite Heuristik die für Prädikatenlogik 1. Ordnung angewandt werden kann, ist zur Auswahl eines abzuleitenden mehrfach ableitbaren Quantors. Die Heuristik ordnet jeder Formel eine Priorität zu, die der Kardinalität der Menge der bereits auf den Quantor angewandten Konstanten und Funktionen entspricht. Quantoren mit niedrigerer Kardinalität werden gegenüber solchen mit höherer bevorzugt da diese seltener abgeleitet wurden.


\subsection{Intuitionistische Aussagenlogik}
Wie in \autoref{sec:intuitionistic_rules} eingeführt, wird zur Berechnung von Intuitionistischer Aussagenlogik eine Menge von definitiv falschen Aussagen eingeführt. Diese werden in dem Seqent ebenfalls durch zusätzliche Mengen repräsentiert. Zudem wird eine Menge für die mehrfach Ableitbaren Implikationen benötigt. Der Sequent S ist also ein Zehntupel (T, F, CF, $\Gamma$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I). Die zusätzlichen Mengen haben folgende Bedeutung:

\begin{description}
\item \textbf{CF}: Die Menge der definitiv falschen Aussagen.

\item \textbf{$\Lambda$}: Die Menge der Formeln die in vorherigen Ableitungsschritten abgeleitet wurden und dabei in der Menge der definitiv falschen Aussagen war.

\item \textbf{Z}: Die Menge der definitiv falschen atomaren Aussagen.

\item \textbf{I}: Menge von Tupeln ($\alpha$, k). Wobei $\alpha$ eine bereits k-Mal abgeleitete Implikation auf der Wahr-Seite ist.
\end{description}

In Intuitionistischer Aussagenlogik wird abgeleitet bis gilt $\exists\alpha(\alpha\in\Theta\wedge(\alpha\in\Psi\vee\alpha\in\textrm{Z}))\vee\neg\exists\alpha(\alpha\in\textrm{T}\vee\alpha\in\textrm{F}\vee\alpha\in\textrm{CF}\vee\alpha\in\textrm{I})$.

Zu den Regeln der einzelnen Operatoren kommt jeweils eine Regel für Formeln in der definitiv Falsch Menge hinzu.

\subsubsection{Atomare Aussage}
Wenn $\alpha\in\textrm{T}$ dann folgt S'=($\textrm{T}\setminus\lbrace\alpha\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\rbrace$, $\Pi$, $\Lambda$, $\Theta\cup\lbrace\alpha\rbrace$, $\Psi$, Z, I).\\
Wenn $\alpha\in\textrm{F}$ dann folgt S'=(T, $\textrm{F}\setminus\lbrace\alpha\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\alpha\rbrace$, $\Lambda$, $\Theta$, $\Psi\cup\lbrace\alpha\rbrace$, Z, I).\\
Wenn $\alpha\in\textrm{CF}$ dann folgt S'=(T, F, $\textrm{CF}\setminus\lbrace\alpha\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\alpha\rbrace$, $\Theta$, $\Psi$, $\textrm{Z}\cup\lbrace\alpha\rbrace$, I).

\subsubsection{Negation}
Wenn $\neg\alpha\in\textrm{T}$ dann folgt S'=($\textrm{T}\setminus\lbrace\neg\alpha\rbrace$, F, $\textrm{CF}\cup\lbrace\alpha\rbrace$, $\Gamma\cup\lbrace\neg\alpha\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\neg\alpha\in\textrm{F}$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $\lbrace\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\neg\alpha\rbrace$, $\Lambda$, $\Theta$, $\Psi$, Z, I).
Wenn $\neg\alpha\in\textrm{CF}$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $\lbrace\rbrace$, $\textrm{CF}\setminus\lbrace\neg\alpha\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\neg\alpha\rbrace$, $\Theta$, $\Psi$, Z, I).

\subsubsection{Konjunktion}
Wenn $\alpha\wedge\beta\in\textrm{T}$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha,\beta\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\wedge\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\wedge\beta\in\textrm{F}$ dann folgt S$_{1}$'=(T, $(\textrm{F}\cup\lbrace\alpha\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\alpha\wedge\beta\rbrace$, $\Lambda$, $\Theta$, $\Psi$, Z, I) und S$_{2}$'=(T, $(\textrm{F}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\alpha\wedge\beta\rbrace$, $\Lambda$, $\Theta$, $\Psi$, Z, I). \\
Wenn $\alpha\wedge\beta\in\textrm{CF}$ dann folgt S$_{1}$'=(T, F, $(\textrm{CF}\cup\lbrace\alpha\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\alpha\wedge\beta\rbrace$, $\Theta$, $\Psi$, Z, I) und S$_{2}$'=(T, F, $(\textrm{CF}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\wedge\beta\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\alpha\wedge\beta\rbrace$, $\Theta$, $\Psi$, Z, I).

\subsubsection{Disjunktion}
Wenn $\alpha\vee\beta\in\textrm{T}$ dann folgt S$_{1}$'=($(\textrm{T}\cup\lbrace\alpha\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\vee\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I) und S$_{2}$'=($(\textrm{T}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\vee\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\vee\beta\in\textrm{F}$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha,\beta\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\alpha\vee\beta\rbrace$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\vee\beta\in\textrm{CF}$ dann folgt S'=(T, F, $(\textrm{CF}\cup\lbrace\alpha,\beta\rbrace)\setminus\lbrace\alpha\vee\beta\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\alpha\vee\beta\rbrace$, $\Theta$, $\Psi$, Z, I).

\subsubsection{Implikation}
Wenn $\alpha\rightarrow\beta\in\textrm{T}$ dann folgt S$_{1}$'=($\textrm{T}\setminus\lbrace\alpha\rightarrow\beta\rbrace$, $\textrm{F}\cup\lbrace\alpha\rbrace$, CF, $\Gamma\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, $\textrm{I}\cup\lbrace(\alpha\rightarrow\beta, 1)\rbrace$) und S$_{2}$'=($(\textrm{T}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\rightarrow\beta\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\rightarrow\beta\in\textrm{F}$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $\lbrace\beta\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\rightarrow\beta\in\textrm{CF}$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha\rbrace$, $\lbrace\beta\rbrace$, $\textrm{CF}\setminus\lbrace\alpha\rightarrow\beta\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Theta$, $\Psi$, Z, I).\\
Wenn $(\alpha\rightarrow\beta, k)\in\textrm{I}$ dann folgt S$_{1}$'=(T, $\textrm{F}\cup\lbrace\alpha\rbrace$, CF, $\Gamma\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, $(\textrm{I}\setminus\lbrace(\alpha\rightarrow\beta, k)\rbrace)\cup\lbrace(\alpha\rightarrow\beta, k+1)\rbrace$) und S$_{2}$'=($(\textrm{T}\cup\lbrace\beta\rbrace)\setminus\lbrace\alpha\rightarrow\beta\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\rightarrow\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I).

\subsubsection{Äquivalenz}
Wenn $\alpha\leftrightarrow\beta\in\textrm{T}$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha\rightarrow\beta\wedge\beta\rightarrow\alpha\rbrace)\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, F, CF, $\Gamma\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\leftrightarrow\beta\in\textrm{F}$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha\rightarrow\beta\wedge\beta\rightarrow\alpha\rbrace)\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Lambda$, $\Theta$, $\Psi$, Z, I).\\
Wenn $\alpha\leftrightarrow\beta\in\textrm{CF}$ dann folgt S'=(T, F, $(\textrm{CF}\cup\lbrace\alpha\rightarrow\beta\wedge\beta\rightarrow\alpha\rbrace)\setminus\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\alpha\leftrightarrow\beta\rbrace$, $\Theta$, $\Psi$, Z, I).

\subsubsection{Heuristiken}
Zusätzlich zu den bereits zuvor definierten Heuristiken, kann in der intuitionistischen Logik eine Heuristik zur Ableitung von Implikationen in I eingeführt werden. Diese werden erst abgeleitet, wenn keine anderen Formeln mehr abzuleiten sind. Dann gilt, die nächste abzuleitende Implikation, ist die, die mit der kleinsten Zahl im Tupel in I steht.


\subsection{Intuitionistische Prädikatenlogik 1. Ordnung}
Zur Berechnung von intuitionistischer Prädikatenlogik 1. Ordnung, wird der Sequent der intuitionistischen Aussagenlogik um weitere Mengen erweitert. Es werden die bereits für die klassische Prädikatenlogik 1. Ordnung eingeführten Mengen für mehrfach ableitbare Quantifizierungen und 2 Mengen für mehrfach ableitbare Quantifizierungen aus der Menge der definitiv Falschen Aussagen eingeführt. Es ergibt sich ein 16-Tupel (T, F, CF, $\Gamma$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, Z, $\Sigma$, $\Phi$, K, U, I, C, $\Omega$). Die zusätzlichen Mengen haben folgende Bedeutung:

\begin{description}
\item \textbf{K}: Menge von Tupeln $(\alpha, \sigma)$. Wobei $\alpha$ ein bereits abgeleiteter Existenzquantor in der Menge der definitiv falschen Aussagen ist und $\sigma$ die Menge der Konstanten/Funktionen die bereits auf den Quantor angewendet wurden.

\item \textbf{U}: Menge von Tupeln $(\alpha, \textrm{k})$. Wobei $\alpha$ ein bereits abgeleiteter Allquantor in der Menge der definitiv falschen Aussagen ist der bereits k mal abgeleitet wurde.
\end{description}

In Intuitionistischer Prädikatenlogik 1. Ordnung wird abgeleitet bis gilt $\exists\alpha(\alpha\in\Theta\wedge(\alpha\in\Psi\vee\alpha\in\textrm{Z}))\vee\neg\exists\alpha(\alpha\in\textrm{T}\vee\alpha\in\textrm{F}\vee\alpha\in\textrm{CF}\vee\alpha\in\textrm{I}\vee\alpha\in\textrm{U})\wedge\forall\textrm{c}(\textrm{c}\in\textrm{C}\rightarrow\neg\exists(\alpha,\sigma)((\alpha,\sigma)\in\Sigma\wedge\textrm{c}\notin\sigma)\wedge\neg\exists(\alpha,\sigma)((\alpha,\sigma)\in\Phi\wedge\textrm{c}\notin\sigma)\wedge\neg\exists(\alpha,\sigma)((\alpha,\sigma)\in\textrm{K}\wedge\textrm{c}\notin\sigma))$. Wie auch in der klassischen Prädikatenlogik 1. Ordnung, gilt diese Aussage nur, wenn es keine mehrstelligen Funktionen in $\Omega$ vorhanden sind, da ansonsten unendlich tiefe Verschachtelungen auf mehrfach ableitbare Quantoren angewandt werden müssen.

Die Ableitungsregeln der Quantoren sind die folgt definiert.
\subsubsection{Allquantor}
Wenn $\forall\textrm{x}$ $\alpha\in\textrm{T}$ und $\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega))\rbrace)\setminus\lbrace\forall\textrm{x}$ $\alpha\rbrace$, F, CF, $\Gamma\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma\cup\lbrace(\forall\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega))\rbrace$, $\Phi$, K, U, I, C, $\Omega$).

Wenn $\forall\textrm{x}$ $\alpha\in\textrm{T}$ und $\neg\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=($(\textrm{T}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace)\setminus\lbrace\forall\textrm{x}$ $\alpha\rbrace$, F, CF, $\Gamma\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma\cup\lbrace(\forall\textrm{x}$ $\alpha,\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace$, $\Phi$, K, U, I, $\lbrace\textrm{t}\rbrace$, $\Omega$).

Wenn $(\forall\textrm{x}$ $\alpha, \sigma)\in\Sigma$ dann folgt S'=($\textrm{T}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega)\wedge\neg\textrm{applied(t},\forall\textrm{x}$ $\alpha, \Sigma)\rbrace$, F, CF, $\Gamma$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, $(\Sigma\setminus\lbrace(\forall\textrm{x}$ $\alpha, \sigma)\rbrace)\cup\lbrace(\forall\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega)\rbrace$, $\Phi$, K, U, I, C, $\Omega$).

Wenn $\forall\textrm{x}$ $\alpha\in\textrm{F}$ und k eine Konstante die nicht in C vorhanden, dann folgt S'=(T, $\lbrace\alpha[k/x]\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, K, U, I, $\textrm{C}\cup\lbrace\textrm{k}\rbrace$, $\Omega$).

Wenn $\forall\textrm{x}$ $\alpha\in\textrm{CF}$ und k eine Konstante die nicht in C vorhanden, dann folgt S'=(T, $\lbrace\alpha[k/x]\rbrace$, CF, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, K, $\textrm{U}\cup\lbrace(\forall\textrm{x}$ $\alpha, 1)\rbrace$, I, $\textrm{C}\cup\lbrace\textrm{k}\rbrace$, $\Omega$).

Wenn $(\forall\textrm{x}$ $\alpha, i)\in\textrm{U}$ und k eine Konstante die nicht in C vorhanden, dann folgt S'=(T, $\lbrace\alpha[k/x]\rbrace$, CF, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\forall\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, K, $(\textrm{U}\setminus\lbrace(\forall\textrm{x}$ $\alpha, i)\rbrace)\cup\lbrace(\forall\textrm{x}$ $\alpha, i+1)\rbrace$, I, $\textrm{C}\cup\lbrace\textrm{k}\rbrace$, $\Omega$).

\subsubsection{Existenzquantor}
Wenn $\exists\textrm{x}$ $\alpha\in\textrm{T}$ und k eine Konstante die nicht in C vorhanden, dann folgt S'=($\textrm{T}\cup\lbrace\alpha[k/x]\rbrace$, F, CF, $\Gamma\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, K, U, I, $\textrm{C}\cup\lbrace\textrm{k}\rbrace$, $\Omega$).

Wenn $\exists\textrm{x}$ $\alpha\in\textrm{F}$ und $\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega))\rbrace)\setminus\lbrace\exists\textrm{x}$ $\alpha\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma$, $\Phi\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega))\rbrace$, K, U, I, C, $\Omega$).

Wenn $\exists\textrm{x}$ $\alpha\in\textrm{F}$ und $\neg\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=(T, $(\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace)\setminus\lbrace\exists\textrm{x}$ $\alpha\rbrace$, CF, $\Gamma$, $\Pi\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma$, $\Phi\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace$, K, U, I, $\lbrace\textrm{t}\rbrace$, $\Omega$).

Wenn $(\exists\textrm{x}$ $\alpha, \sigma)\in\Phi$ dann folgt S'=(T, $\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega)\wedge\neg\textrm{applied(t},\exists\textrm{x}$ $\alpha, \Phi))\rbrace$, CF, $\Gamma$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma$, $(\Phi\setminus\lbrace(\exists\textrm{x}$ $\alpha, \sigma)\rbrace)\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega)\rbrace$, K, U, I, C, $\Omega$).

Wenn $\exists\textrm{x}$ $\alpha\in\textrm{CF}$ und $\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=(T, $\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega))\rbrace)$, $\textrm{CF}\setminus\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, $\textrm{K}\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega))\rbrace$, U, I, C, $\Omega$).

Wenn $\exists\textrm{x}$ $\alpha\in\textrm{CF}$ und $\neg\exists\textrm{t}(\textrm{t}\in\textrm{C})$ dann folgt S'=(T, $\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace$, $\textrm{CF}\setminus\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Gamma$, $\Pi$, $\Lambda\cup\lbrace\exists\textrm{x}$ $\alpha\rbrace$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, $\textrm{K}\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(}\lbrace\textrm{t}\rbrace,\Omega))\rbrace$, U, I, $\lbrace\textrm{t}\rbrace$, $\Omega$).

Wenn $(\exists\textrm{x}$ $\alpha, \sigma)\in\textrm{K}$ dann folgt S'=(T, $\textrm{F}\cup\lbrace\alpha[t/x]|\forall\textrm{t}(\textrm{t}\in\textrm{permute(C,}\Omega)\wedge\neg\textrm{applied(t},\exists\textrm{x}$ $\alpha, \textrm{K}))\rbrace$, CF, $\Gamma$, $\Pi$, $\Lambda$, $\Theta$, $\Psi$, $\Sigma$, $\Phi$, $(\textrm{K}\setminus\lbrace(\exists\textrm{x}$ $\alpha, \sigma)\rbrace)\cup\lbrace(\exists\textrm{x}$ $\alpha,\textrm{permute(C,}\Omega)\rbrace$, U, I, C, $\Omega$).


\subsection{Ablauf}
Wie bereits während der Definition der Sequenten angedeutet, läuft die Berechnung im Automatik Modus in 3 Schritten ab:

\begin{enumerate}
\item Prüfe, ob Bedingung zur Weiterberechnung erfüllt (siehe Definition). Falls nicht, fertig.

\item Wähle unter Verwendung der definierten Heuristiken die nächste abzuleitende Formel $\alpha$ aus.

\item Leite $\alpha$ mit den definierten Regeln ab, indem die ``visit''-Funktion auf $\alpha$ aufgerufen wird, welche die entsprechende Ableitungsregel-Funktion auf dem Tableau aufruft. Weiter bei 1.
\end{enumerate}

Das Tableau wird zur Berechnung in einer Baumstruktur gehalten. Das heißt, wird eine verzweigende Ableitung berechnet, werden neue Tableaux erzeugt und als Kindknoten gehalten. Wenn ein Tableau Kindknoten hält, wird der Ablauf auf jedem Kindknoten ausgeführt.

\section{Manueller Modus}
Der Grundgedanke hinter dem Manuellen Modus ist folgender: Im manuellen Modus, wird die Wahl der als nächstes abzuleitenden Formel dem User überlassen. Wählt dieser eine Formel durch betätigen des entsprechenden Buttons aus, wird ein temporäres Tableau welches nur die ausgewählte Formel hält erzeugt. Für diese wird anschließend die Ableitungsregel ausgeführt. Die vom User eingegebene Ableitung, wird dann mit der im temporären Tableau verglichen. Sind die beiden identisch, wird das temporäre Tableau mit dem ``Haup''-Tableau gemerged und die nächste Formel kann vom User ausgewählt werden.

Der beschriebene Ablauf ist in einigen Fällen noch nicht ganz optimal, weshalb dieser noch erweitert werden muss.

\subsection{Permutation des Syntaxbaums}
In \autoref{sec:parsen}, wurde beschrieben, dass die Formeln als Syntaxbaum im Speicher gehalten werden. Nun ist es so, dass eine Formel wie ``$\alpha\wedge\beta\wedge\gamma$'' zu unterschiedlichen Syntaxbäumen umgewandelt werden kann. Für das Beispiel wären dies $\wedge(\wedge(\alpha,\beta),\gamma)$ und $\wedge(\alpha,\wedge(\beta,\gamma))$. Je nach Aufbau des Syntaxbaums, wird beim oben definierten automatischen Ableiten ein anderer Zwischenschritt erzeugt (siehe \autoref{fig:example_different_syntax_trees}).

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{images/example_different_syntax_trees.png}
\caption{Zwischenschritte nach Ableiten des Syntaxbaums $\wedge(\wedge(\textrm{a},\textrm{b}),\textrm{c})$ (links) und $\wedge(\textrm{a},\wedge(\textrm{b},\textrm{c}))$ (rechts)}
\label{fig:example_different_syntax_trees}
\end{center}
\end{figure}

Würde der manuelle Modus rein wie oben beschrieben umgesetzt, müsste der User die Ableitung immer entsprechend der Form des Syntaxbaums (welche diesem nicht zugänglich ist) eingeben. Deshalb wird der Syntaxbaum vor Erzeugen des temporären Tableau permutiert und für jede der Permutationen ein zusätzliches Tableau erzeugt, welches mit der vom User eingegebenen Ableitung abgeglichen wird. Da die Reihenfolge (von links nach rechts) beibehalten und nur die Hierarchie im Baum permutiert werden soll, können rekursiv Einfachrotationen auf dem Baum ausgeführt werden und die dabei entstehenden Bäume zur Permutationsliste hinzugefügt werden. Eine Rotation darf nur angewendet werden, wenn der Kindknoten die selbe Operation, wie der aktuelle Knoten repräsentiert und diese keine Implikation ist. Die Einfachrotation ist in \autoref{fig:example_tree_rotation} dargestellt.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{images/example_tree_rotation.png}
\caption{Einfachrotation Rechts am Wurzelknoten eines Syntaxbaums (Links vor Rotation, Rechts danach)}
\label{fig:example_tree_rotation}
\end{center}
\end{figure}

\subsection{Konstanten und Funktionen}
Wie bereits in \autoref{sec:umsetzung_pred_logic} erwähnt, wird zur Implementierung der permute-Funktion die erzeugte Verschachtelungstiefe schrittweise erhöht. Würde dieser Ansatz im manuellen Modus naiv weiterverfolgt, müsste jede Verschachtelungstiefe erzeugt und geprüft werden ob der Benutzer alle dieser Formeln eingegeben hat. Dies hat zwei Probleme zur Folge. Erstens, steigt die Menge der erzeugten Formeln mit der Tiefe exponentiell wobei meist nur einige wenige dieser Formeln Zielführend für den Beweis sind. Zu erzwingen, dass der Benutzer alle erzeugten Formeln auflistet ist deshalb nicht zumutbar. Das zweite Problem entsteht, wenn der Benutzer eine falsche Ableitung eingibt. Ist dies der Fall, würden so lange Formeln erzeugt und verglichen, bis die maximale Anzahl an Ableitungsschritten erreicht wurde. Bis diese erreicht ist, dauert allerdings relativ lange, weshalb dieser Ansatz auch unpraktikabel ist.

Zur Lösung des ersten Problems, wird die Prüfung auf Korrektheit der Ableitung bei Quantoren gelockert. Diese ist in diesem Fall korrekt, sobald mindestens ein Element der Permutationsmenge, dass noch nicht auf den Quantor angewendet wurde vom User aufgelistet wurde. Beim Mergen der Tableaux, werden dann nur die vom User aufgelisteten Elemente beachtet.

Die Lösung des zweiten Problems ist etwas schwieriger. Hierfür muss eine praktische Obergrenze der Verschachtelungstiefe gefunden werden. Dafür wird vor dem Erzeugen des temporären Tableau, die eingegebene Ableitung untersucht. Es werden die Verschachtelungstiefen der Funktionen gezählt und die Maximale als Obergrenze für das temporäre Tableau verwendet.





